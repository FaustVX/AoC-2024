// <auto-generated/>
#nullable enable
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // Unreferenced label
#pragma warning disable CS0219 // Variable assigned but never used

namespace AdventOfCode.Y2024.Day03
{
    partial class Solution
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>mul\\((\\d+),(\\d+)\\)</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match the string "mul(".<br/>
        /// ○ 1st capture group.<br/>
        ///     ○ Match a Unicode digit atomically at least once.<br/>
        /// ○ Match ','.<br/>
        /// ○ 2nd capture group.<br/>
        ///     ○ Match a Unicode digit atomically at least once.<br/>
        /// ○ Match ')'.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        static partial global::System.Text.RegularExpressions.Regex ParseMul => global::System.Text.RegularExpressions.Generated.ParseMul_0.Instance;
    }
}

namespace AdventOfCode.Y2024.Day03
{
    partial class Solution
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>mul\\((\\d+),(\\d+)\\)|do\\(\\)|don't\\(\\)</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match with 2 alternative expressions, atomically.<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match an empty string.<br/>
        ///         ○ 1st capture group.<br/>
        ///             ○ Match a Unicode digit atomically at least once.<br/>
        ///         ○ Match ','.<br/>
        ///         ○ 2nd capture group.<br/>
        ///             ○ Match a Unicode digit atomically at least once.<br/>
        ///         ○ Match ')'.<br/>
        ///     ○ Match a sequence of expressions.<br/>
        ///         ○ Match an empty string.<br/>
        ///         ○ Match with 2 alternative expressions, atomically.<br/>
        ///             ○ Match the string "()".<br/>
        ///             ○ Match the string "n't()".<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        static partial global::System.Text.RegularExpressions.Regex ParseMulDo => global::System.Text.RegularExpressions.Generated.ParseMulDo_1.Instance;
    }
}

namespace AdventOfCode.Model
{
    partial class Calendar
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>[.0-9]+</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match a character in the set [.0-9] atomically at least once.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        private static partial global::System.Text.RegularExpressions.Regex WidthRegex() => global::System.Text.RegularExpressions.Generated.WidthRegex_2.Instance;
    }
}

namespace AdventOfCode.Model
{
    partial class Calendar
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>rgba\\((?&lt;r&gt;\\d{1,3}), (?&lt;g&gt;\\d{1,3}), (?&lt;b&gt;\\d{1,3}), (?&lt;a&gt;\\d{1,3})\\)</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match the string "rgba(".<br/>
        /// ○ "r" capture group.<br/>
        ///     ○ Match a Unicode digit atomically at least 1 and at most 3 times.<br/>
        /// ○ Match the string ", ".<br/>
        /// ○ "g" capture group.<br/>
        ///     ○ Match a Unicode digit atomically at least 1 and at most 3 times.<br/>
        /// ○ Match the string ", ".<br/>
        /// ○ "b" capture group.<br/>
        ///     ○ Match a Unicode digit atomically at least 1 and at most 3 times.<br/>
        /// ○ Match the string ", ".<br/>
        /// ○ "a" capture group.<br/>
        ///     ○ Match a Unicode digit atomically at least 1 and at most 3 times.<br/>
        /// ○ Match ')'.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        private static partial global::System.Text.RegularExpressions.Regex RGBAColorRegex() => global::System.Text.RegularExpressions.Generated.RGBAColorRegex_3.Instance;
    }
}

namespace AdventOfCode.Model
{
    partial class Problem
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>.*: (.*) ---</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match a character other than '\n' greedily any number of times.<br/>
        /// ○ Match the string ": ".<br/>
        /// ○ 1st capture group.<br/>
        ///     ○ Match a character other than '\n' greedily any number of times.<br/>
        /// ○ Match the string " ---".<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        private static partial global::System.Text.RegularExpressions.Regex TitleRegex() => global::System.Text.RegularExpressions.Generated.TitleRegex_4.Instance;
    }
}

namespace AdventOfCode
{
    partial class StringExtensions
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>\r?\n</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match '\r' atomically, optionally.<br/>
        /// ○ Match '\n'.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        private static partial global::System.Text.RegularExpressions.Regex NewLineRegex() => global::System.Text.RegularExpressions.Generated.NewLineRegex_5.Instance;
    }
}

namespace AdventOfCode
{
    partial class StringExtensions
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>\\s</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match a whitespace character.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        private static partial global::System.Text.RegularExpressions.Regex WhitespaceRegex() => global::System.Text.RegularExpressions.Generated.WhitespaceRegex_6.Instance;
    }
}

namespace AdventOfCode
{
    partial class StringExtensions
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>(\r?\n){2}</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Loop exactly 2 times.<br/>
        ///     ○ 1st capture group.<br/>
        ///         ○ Match '\r' atomically, optionally.<br/>
        ///         ○ Match '\n'.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        private static partial global::System.Text.RegularExpressions.Regex NewLine2Regex() => global::System.Text.RegularExpressions.Generated.NewLine2Regex_7.Instance;
    }
}

namespace AdventOfCode
{
    partial class Updater
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>\\[Continue to Part Two.*</code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.Singleline</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match the string "[Continue to Part Two".<br/>
        /// ○ Match any character atomically any number of times.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        private static partial global::System.Text.RegularExpressions.Regex ContinueToPart2Regex() => global::System.Text.RegularExpressions.Generated.ContinueToPart2Regex_8.Instance;
    }
}

namespace AdventOfCode
{
    partial class Updater
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>You have completed Day.*</code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.Singleline</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match the string "You have completed Day".<br/>
        /// ○ Match any character atomically any number of times.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        private static partial global::System.Text.RegularExpressions.Regex YouHaveCompletedDayRegex() => global::System.Text.RegularExpressions.Generated.YouHaveCompletedDayRegex_9.Instance;
    }
}

namespace AdventOfCode
{
    partial class Updater
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>\\(You guessed.*</code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.Singleline</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match the string "(You guessed".<br/>
        /// ○ Match any character atomically any number of times.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        private static partial global::System.Text.RegularExpressions.Regex YouGuessedRegex() => global::System.Text.RegularExpressions.Generated.YouGuessedRegex_10.Instance;
    }
}

namespace AdventOfCode
{
    partial class Updater
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>  </code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.Singleline</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match the string "  ".<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
        private static partial global::System.Text.RegularExpressions.Regex SpacesRegex() => global::System.Text.RegularExpressions.Generated.SpacesRegex_11.Instance;
    }
}

namespace System.Text.RegularExpressions.Generated
{
    using System;
    using System.Buffers;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;
    using System.Threading;

    /// <summary>Custom <see cref="Regex"/>-derived type for the ParseMul method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class ParseMul_0 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly ParseMul_0 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private ParseMul_0()
        {
            base.pattern = "mul\\((\\d+),(\\d+)\\)";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 3;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 8 characters.
                    if (pos <= inputSpan.Length - 8)
                    {
                        // The pattern has the literal "mul(" at the beginning of the pattern. Find the next occurrence.
                        // If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_indexOfString_96014D68D1DA3A16D426C930D9D5FE25B48BBEF3E7AA9B0FFBC6DD9BE4DC8030);
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int capture_starting_pos = 0;
                    int capture_starting_pos1 = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match the string "mul(".
                    if (!slice.StartsWith("mul("))
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // 1st capture group.
                    {
                        pos += 4;
                        slice = inputSpan.Slice(pos);
                        capture_starting_pos = pos;
                        
                        // Match a Unicode digit atomically at least once.
                        {
                            int iteration = 0;
                            while ((uint)iteration < (uint)slice.Length && char.IsDigit(slice[iteration]))
                            {
                                iteration++;
                            }
                            
                            if (iteration == 0)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            
                            slice = slice.Slice(iteration);
                            pos += iteration;
                        }
                        
                        base.Capture(1, capture_starting_pos, pos);
                    }
                    
                    // Match ','.
                    if (slice.IsEmpty || slice[0] != ',')
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // 2nd capture group.
                    {
                        pos++;
                        slice = inputSpan.Slice(pos);
                        capture_starting_pos1 = pos;
                        
                        // Match a Unicode digit atomically at least once.
                        {
                            int iteration1 = 0;
                            while ((uint)iteration1 < (uint)slice.Length && char.IsDigit(slice[iteration1]))
                            {
                                iteration1++;
                            }
                            
                            if (iteration1 == 0)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            
                            slice = slice.Slice(iteration1);
                            pos += iteration1;
                        }
                        
                        base.Capture(2, capture_starting_pos1, pos);
                    }
                    
                    // Match ')'.
                    if (slice.IsEmpty || slice[0] != ')')
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // The input matched.
                    pos++;
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the ParseMulDo method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class ParseMulDo_1 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly ParseMulDo_1 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private ParseMulDo_1()
        {
            base.pattern = "mul\\((\\d+),(\\d+)\\)|do\\(\\)|don't\\(\\)";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 3;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    char ch;
                    
                    // Any possible match is at least 4 characters.
                    if (pos <= inputSpan.Length - 4)
                    {
                        // The pattern begins with a character in the set [dm].
                        // Find the next occurrence. If it can't be found, there's no match.
                        ReadOnlySpan<char> span = inputSpan.Slice(pos);
                        for (int i = 0; i < span.Length - 3; i++)
                        {
                            int indexOfPos = span.Slice(i).IndexOfAny('d', 'm');
                            if (indexOfPos < 0)
                            {
                                goto NoMatchFound;
                            }
                            i += indexOfPos;
                            
                            // The primary set being searched for was found. 2 more sets will be checked so as
                            // to minimize the number of places TryMatchAtCurrentPosition is run unnecessarily.
                            // Make sure they fit in the remainder of the input.
                            if ((uint)(i + 2) >= (uint)span.Length)
                            {
                                goto NoMatchFound;
                            }
                            
                            if ((((ch = span[i + 1]) == 'o') | (ch == 'u')) &&
                                (((ch = span[i + 2]) == '(') | (ch == 'l') | (ch == 'n')))
                            {
                                base.runtextpos = pos + i;
                                return true;
                            }
                        }
                    }
                    
                    // No match found.
                    NoMatchFound:
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int capture_starting_pos = 0;
                    int capture_starting_pos1 = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match with 2 alternative expressions, atomically.
                    {
                        if (slice.IsEmpty)
                        {
                            UncaptureUntil(0);
                            return false; // The input didn't match.
                        }
                        
                        switch (slice[0])
                        {
                            case 'm':
                                // Match the string "ul(".
                                if (!slice.Slice(1).StartsWith("ul("))
                                {
                                    UncaptureUntil(0);
                                    return false; // The input didn't match.
                                }
                                
                                
                                // 1st capture group.
                                {
                                    pos += 4;
                                    slice = inputSpan.Slice(pos);
                                    capture_starting_pos = pos;
                                    
                                    // Match a Unicode digit atomically at least once.
                                    {
                                        int iteration = 0;
                                        while ((uint)iteration < (uint)slice.Length && char.IsDigit(slice[iteration]))
                                        {
                                            iteration++;
                                        }
                                        
                                        if (iteration == 0)
                                        {
                                            UncaptureUntil(0);
                                            return false; // The input didn't match.
                                        }
                                        
                                        slice = slice.Slice(iteration);
                                        pos += iteration;
                                    }
                                    
                                    base.Capture(1, capture_starting_pos, pos);
                                }
                                
                                // Match ','.
                                if (slice.IsEmpty || slice[0] != ',')
                                {
                                    UncaptureUntil(0);
                                    return false; // The input didn't match.
                                }
                                
                                // 2nd capture group.
                                {
                                    pos++;
                                    slice = inputSpan.Slice(pos);
                                    capture_starting_pos1 = pos;
                                    
                                    // Match a Unicode digit atomically at least once.
                                    {
                                        int iteration1 = 0;
                                        while ((uint)iteration1 < (uint)slice.Length && char.IsDigit(slice[iteration1]))
                                        {
                                            iteration1++;
                                        }
                                        
                                        if (iteration1 == 0)
                                        {
                                            UncaptureUntil(0);
                                            return false; // The input didn't match.
                                        }
                                        
                                        slice = slice.Slice(iteration1);
                                        pos += iteration1;
                                    }
                                    
                                    base.Capture(2, capture_starting_pos1, pos);
                                }
                                
                                // Match ')'.
                                if (slice.IsEmpty || slice[0] != ')')
                                {
                                    UncaptureUntil(0);
                                    return false; // The input didn't match.
                                }
                                
                                pos++;
                                slice = inputSpan.Slice(pos);
                                break;
                                
                            case 'd':
                                // Match 'o'.
                                if ((uint)slice.Length < 2 || slice[1] != 'o')
                                {
                                    UncaptureUntil(0);
                                    return false; // The input didn't match.
                                }
                                
                                
                                // Match with 2 alternative expressions, atomically.
                                {
                                    if ((uint)slice.Length < 3)
                                    {
                                        UncaptureUntil(0);
                                        return false; // The input didn't match.
                                    }
                                    
                                    switch (slice[2])
                                    {
                                        case '(':
                                            // Match ')'.
                                            if ((uint)slice.Length < 4 || slice[3] != ')')
                                            {
                                                UncaptureUntil(0);
                                                return false; // The input didn't match.
                                            }
                                            
                                            pos += 4;
                                            slice = inputSpan.Slice(pos);
                                            break;
                                            
                                        case 'n':
                                            // Match the string "'t()".
                                            if (!slice.Slice(3).StartsWith("'t()"))
                                            {
                                                UncaptureUntil(0);
                                                return false; // The input didn't match.
                                            }
                                            
                                            pos += 7;
                                            slice = inputSpan.Slice(pos);
                                            break;
                                            
                                        default:
                                            UncaptureUntil(0);
                                            return false; // The input didn't match.
                                    }
                                }
                                
                                break;
                                
                            default:
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                        }
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the WidthRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class WidthRegex_2 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly WidthRegex_2 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private WidthRegex_2()
        {
            base.pattern = "[.0-9]+";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Empty matches aren't possible.
                    if ((uint)pos < (uint)inputSpan.Length)
                    {
                        // The pattern begins with a character in the set [.0-9].
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_ascii_40FF030000000000000000);
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match a character in the set [.0-9] atomically at least once.
                    {
                        int iteration = slice.IndexOfAnyExcept(Utilities.s_ascii_40FF030000000000000000);
                        if (iteration < 0)
                        {
                            iteration = slice.Length;
                        }
                        
                        if (iteration == 0)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration);
                        pos += iteration;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the RGBAColorRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class RGBAColorRegex_3 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly RGBAColorRegex_3 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private RGBAColorRegex_3()
        {
            base.pattern = "rgba\\((?<r>\\d{1,3}), (?<g>\\d{1,3}), (?<b>\\d{1,3}), (?<a>\\d{1,3})\\)";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.CapNames = new Hashtable { { "0", 0 } ,  { "a", 4 } ,  { "b", 3 } ,  { "g", 2 } ,  { "r", 1 }  };
            base.capslist = new string[] {"0", "r", "g", "b", "a" };
            base.capsize = 5;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 16 characters.
                    if (pos <= inputSpan.Length - 16)
                    {
                        // The pattern has the literal "rgba(" at the beginning of the pattern. Find the next occurrence.
                        // If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_indexOfString_51CECF572885F990C73E7697216BC69E1AA29EEBA5DD34AEDC627AE466501040);
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int capture_starting_pos = 0;
                    int capture_starting_pos1 = 0;
                    int capture_starting_pos2 = 0;
                    int capture_starting_pos3 = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match the string "rgba(".
                    if (!slice.StartsWith("rgba("))
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // "r" capture group.
                    {
                        pos += 5;
                        slice = inputSpan.Slice(pos);
                        capture_starting_pos = pos;
                        
                        // Match a Unicode digit atomically at least 1 and at most 3 times.
                        {
                            int iteration = 0;
                            while (iteration < 3 && (uint)iteration < (uint)slice.Length && char.IsDigit(slice[iteration]))
                            {
                                iteration++;
                            }
                            
                            if (iteration == 0)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            
                            slice = slice.Slice(iteration);
                            pos += iteration;
                        }
                        
                        base.Capture(1, capture_starting_pos, pos);
                    }
                    
                    // Match the string ", ".
                    if (!slice.StartsWith(", "))
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // "g" capture group.
                    {
                        pos += 2;
                        slice = inputSpan.Slice(pos);
                        capture_starting_pos1 = pos;
                        
                        // Match a Unicode digit atomically at least 1 and at most 3 times.
                        {
                            int iteration1 = 0;
                            while (iteration1 < 3 && (uint)iteration1 < (uint)slice.Length && char.IsDigit(slice[iteration1]))
                            {
                                iteration1++;
                            }
                            
                            if (iteration1 == 0)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            
                            slice = slice.Slice(iteration1);
                            pos += iteration1;
                        }
                        
                        base.Capture(2, capture_starting_pos1, pos);
                    }
                    
                    // Match the string ", ".
                    if (!slice.StartsWith(", "))
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // "b" capture group.
                    {
                        pos += 2;
                        slice = inputSpan.Slice(pos);
                        capture_starting_pos2 = pos;
                        
                        // Match a Unicode digit atomically at least 1 and at most 3 times.
                        {
                            int iteration2 = 0;
                            while (iteration2 < 3 && (uint)iteration2 < (uint)slice.Length && char.IsDigit(slice[iteration2]))
                            {
                                iteration2++;
                            }
                            
                            if (iteration2 == 0)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            
                            slice = slice.Slice(iteration2);
                            pos += iteration2;
                        }
                        
                        base.Capture(3, capture_starting_pos2, pos);
                    }
                    
                    // Match the string ", ".
                    if (!slice.StartsWith(", "))
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // "a" capture group.
                    {
                        pos += 2;
                        slice = inputSpan.Slice(pos);
                        capture_starting_pos3 = pos;
                        
                        // Match a Unicode digit atomically at least 1 and at most 3 times.
                        {
                            int iteration3 = 0;
                            while (iteration3 < 3 && (uint)iteration3 < (uint)slice.Length && char.IsDigit(slice[iteration3]))
                            {
                                iteration3++;
                            }
                            
                            if (iteration3 == 0)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            
                            slice = slice.Slice(iteration3);
                            pos += iteration3;
                        }
                        
                        base.Capture(4, capture_starting_pos3, pos);
                    }
                    
                    // Match ')'.
                    if (slice.IsEmpty || slice[0] != ')')
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // The input matched.
                    pos++;
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the TitleRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class TitleRegex_4 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly TitleRegex_4 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private TitleRegex_4()
        {
            base.pattern = ".*: (.*) ---";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 2;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 6 characters.
                    if (pos <= inputSpan.Length - 6)
                    {
                        // The pattern begins with a character in the set [^\n].
                        // Find the next occurrence. If it can't be found, there's no match.
                        ReadOnlySpan<char> span = inputSpan.Slice(pos);
                        for (int i = 0; i < span.Length; i++)
                        {
                            if ((span[i] != '\n'))
                            {
                                base.runtextpos = pos + i;
                                return true;
                            }
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int capture_starting_pos = 0;
                    int charloop_capture_pos = 0;
                    int charloop_capture_pos1 = 0;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    int charloop_starting_pos1 = 0, charloop_ending_pos1 = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match a character other than '\n' greedily any number of times.
                    //{
                        charloop_starting_pos = pos;
                        
                        int iteration = slice.IndexOf('\n');
                        if (iteration < 0)
                        {
                            iteration = slice.Length;
                        }
                        
                        slice = slice.Slice(iteration);
                        pos += iteration;
                        
                        charloop_ending_pos = pos;
                        goto CharLoopEnd;
                        
                        CharLoopBacktrack:
                        UncaptureUntil(charloop_capture_pos);
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        if (charloop_starting_pos >= charloop_ending_pos ||
                            (charloop_ending_pos = inputSpan.Slice(charloop_starting_pos, Math.Min(inputSpan.Length, charloop_ending_pos + 1) - charloop_starting_pos).LastIndexOf(": ")) < 0)
                        {
                            UncaptureUntil(0);
                            return false; // The input didn't match.
                        }
                        charloop_ending_pos += charloop_starting_pos;
                        pos = charloop_ending_pos;
                        slice = inputSpan.Slice(pos);
                        
                        CharLoopEnd:
                        charloop_capture_pos = base.Crawlpos();
                    //}
                    
                    // Advance the next matching position.
                    if (base.runtextpos < pos)
                    {
                        base.runtextpos = pos;
                    }
                    
                    // Match the string ": ".
                    if (!slice.StartsWith(": "))
                    {
                        goto CharLoopBacktrack;
                    }
                    
                    // 1st capture group.
                    //{
                        pos += 2;
                        slice = inputSpan.Slice(pos);
                        capture_starting_pos = pos;
                        
                        // Match a character other than '\n' greedily any number of times.
                        //{
                            charloop_starting_pos1 = pos;
                            
                            int iteration1 = slice.IndexOf('\n');
                            if (iteration1 < 0)
                            {
                                iteration1 = slice.Length;
                            }
                            
                            slice = slice.Slice(iteration1);
                            pos += iteration1;
                            
                            charloop_ending_pos1 = pos;
                            goto CharLoopEnd1;
                            
                            CharLoopBacktrack1:
                            UncaptureUntil(charloop_capture_pos1);
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos1 >= charloop_ending_pos1 ||
                                (charloop_ending_pos1 = inputSpan.Slice(charloop_starting_pos1, Math.Min(inputSpan.Length, charloop_ending_pos1 + 3) - charloop_starting_pos1).LastIndexOf(" ---")) < 0)
                            {
                                goto CharLoopBacktrack;
                            }
                            charloop_ending_pos1 += charloop_starting_pos1;
                            pos = charloop_ending_pos1;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd1:
                            charloop_capture_pos1 = base.Crawlpos();
                        //}
                        
                        base.Capture(1, capture_starting_pos, pos);
                        
                        goto CaptureSkipBacktrack;
                        
                        CaptureBacktrack:
                        goto CharLoopBacktrack1;
                        
                        CaptureSkipBacktrack:;
                    //}
                    
                    // Match the string " ---".
                    if (!slice.StartsWith(" ---"))
                    {
                        goto CaptureBacktrack;
                    }
                    
                    // The input matched.
                    pos += 4;
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the NewLineRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class NewLineRegex_5 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly NewLineRegex_5 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private NewLineRegex_5()
        {
            base.pattern = "\r?\n";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Empty matches aren't possible.
                    if ((uint)pos < (uint)inputSpan.Length)
                    {
                        // The pattern begins with a character in the set [\n\r].
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny('\n', '\r');
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match '\r' atomically, optionally.
                    {
                        if (!slice.IsEmpty && slice[0] == '\r')
                        {
                            slice = slice.Slice(1);
                            pos++;
                        }
                    }
                    
                    // Match '\n'.
                    if (slice.IsEmpty || slice[0] != '\n')
                    {
                        return false; // The input didn't match.
                    }
                    
                    // The input matched.
                    pos++;
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the WhitespaceRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class WhitespaceRegex_6 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly WhitespaceRegex_6 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private WhitespaceRegex_6()
        {
            base.pattern = "\\s";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    if (TryFindNextPossibleStartingPosition(inputSpan))
                    {
                        // The search in TryFindNextPossibleStartingPosition performed the entire match.
                        int start = base.runtextpos;
                        int end = base.runtextpos = start + 1;
                        base.Capture(0, start, end);
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Empty matches aren't possible.
                    if ((uint)pos < (uint)inputSpan.Length)
                    {
                        // The pattern begins with a whitespace character.
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_whitespace);
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the NewLine2Regex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class NewLine2Regex_7 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly NewLine2Regex_7 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private NewLine2Regex_7()
        {
            base.pattern = "(\r?\n){2}";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 2;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 2 characters.
                    if (pos <= inputSpan.Length - 2)
                    {
                        // The pattern begins with a character in the set [\n\r].
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny('\n', '\r');
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Loop exactly 2 times.
                    {
                        for (int loop_iteration = 0; loop_iteration < 2; loop_iteration++)
                        {
                            // 1st capture group.
                            {
                                int capture_starting_pos = pos;
                                
                                // Match '\r' atomically, optionally.
                                {
                                    if (!slice.IsEmpty && slice[0] == '\r')
                                    {
                                        slice = slice.Slice(1);
                                        pos++;
                                    }
                                }
                                
                                // Match '\n'.
                                if (slice.IsEmpty || slice[0] != '\n')
                                {
                                    UncaptureUntil(0);
                                    return false; // The input didn't match.
                                }
                                
                                pos++;
                                slice = inputSpan.Slice(pos);
                                base.Capture(1, capture_starting_pos, pos);
                            }
                        }
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the ContinueToPart2Regex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class ContinueToPart2Regex_8 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly ContinueToPart2Regex_8 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private ContinueToPart2Regex_8()
        {
            base.pattern = "\\[Continue to Part Two.*";
            base.roptions = RegexOptions.Singleline;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 21 characters.
                    if (pos <= inputSpan.Length - 21)
                    {
                        // The pattern has the literal "[Continue to Part Two" at the beginning of the pattern. Find the next occurrence.
                        // If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_indexOfString_E6A228B76E9376A6FE0666728213354BCEC4D51363BA02D548FA5A6F5FE48479);
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match the string "[Continue to Part Two".
                    if (!slice.StartsWith("[Continue to Part Two"))
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Match any character atomically any number of times.
                    {
                        pos += 21;
                        slice = inputSpan.Slice(pos);
                        int iteration = inputSpan.Length - pos;
                        slice = slice.Slice(iteration);
                        pos += iteration;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the YouHaveCompletedDayRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class YouHaveCompletedDayRegex_9 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly YouHaveCompletedDayRegex_9 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private YouHaveCompletedDayRegex_9()
        {
            base.pattern = "You have completed Day.*";
            base.roptions = RegexOptions.Singleline;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 22 characters.
                    if (pos <= inputSpan.Length - 22)
                    {
                        // The pattern has the literal "You have completed Day" at the beginning of the pattern. Find the next occurrence.
                        // If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_indexOfString_3DD9FC9747745A7F6807CE02BD0C493CBCEE2062680A6709E2C4F42C93E5C5B2);
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match the string "You have completed Day".
                    if (!slice.StartsWith("You have completed Day"))
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Match any character atomically any number of times.
                    {
                        pos += 22;
                        slice = inputSpan.Slice(pos);
                        int iteration = inputSpan.Length - pos;
                        slice = slice.Slice(iteration);
                        pos += iteration;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the YouGuessedRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class YouGuessedRegex_10 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly YouGuessedRegex_10 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private YouGuessedRegex_10()
        {
            base.pattern = "\\(You guessed.*";
            base.roptions = RegexOptions.Singleline;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 12 characters.
                    if (pos <= inputSpan.Length - 12)
                    {
                        // The pattern has the literal "(You guessed" at the beginning of the pattern. Find the next occurrence.
                        // If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_indexOfString_8BBF393C3188D3D271FBEB4959A25275CA6CDB7C9743E36C4BCCCD1CB765BDF3);
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match the string "(You guessed".
                    if (!slice.StartsWith("(You guessed"))
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Match any character atomically any number of times.
                    {
                        pos += 12;
                        slice = inputSpan.Slice(pos);
                        int iteration = inputSpan.Length - pos;
                        slice = slice.Slice(iteration);
                        pos += iteration;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the SpacesRegex method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file sealed class SpacesRegex_11 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly SpacesRegex_11 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private SpacesRegex_11()
        {
            base.pattern = "  ";
            base.roptions = RegexOptions.Singleline;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    if (TryFindNextPossibleStartingPosition(inputSpan))
                    {
                        // The search in TryFindNextPossibleStartingPosition performed the entire match.
                        int start = base.runtextpos;
                        int end = base.runtextpos = start + 2;
                        base.Capture(0, start, end);
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 2 characters.
                    if (pos <= inputSpan.Length - 2)
                    {
                        // The pattern has the literal "  " at the beginning of the pattern. Find the next occurrence.
                        // If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAny(Utilities.s_indexOfString_4DF02EB6A8B26A8E8AE968B0C6D57D7D5175C6C3C4EBD7238C244D8A4C1ADD4E);
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
            }
        }

    }
    
    /// <summary>Helper methods used by generated <see cref="Regex"/>-derived implementations.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.11.2809")]
    file static class Utilities
    {
        /// <summary>Default timeout value set in <see cref="AppContext"/>, or <see cref="Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        internal static readonly TimeSpan s_defaultTimeout = AppContext.GetData("REGEX_DEFAULT_MATCH_TIMEOUT") is TimeSpan timeout ? timeout : Regex.InfiniteMatchTimeout;
        
        /// <summary>Whether <see cref="s_defaultTimeout"/> is non-infinite.</summary>
        internal static readonly bool s_hasTimeout = s_defaultTimeout != Regex.InfiniteMatchTimeout;
        
        /// <summary>Supports searching for characters in or not in ".0123456789".</summary>
        internal static readonly SearchValues<char> s_ascii_40FF030000000000000000 = SearchValues.Create(".0123456789");
        
        /// <summary>Supports searching for the string "You have completed Day".</summary>
        internal static readonly SearchValues<string> s_indexOfString_3DD9FC9747745A7F6807CE02BD0C493CBCEE2062680A6709E2C4F42C93E5C5B2 = SearchValues.Create(["You have completed Day"], StringComparison.Ordinal);
        
        /// <summary>Supports searching for the string "  ".</summary>
        internal static readonly SearchValues<string> s_indexOfString_4DF02EB6A8B26A8E8AE968B0C6D57D7D5175C6C3C4EBD7238C244D8A4C1ADD4E = SearchValues.Create(["  "], StringComparison.Ordinal);
        
        /// <summary>Supports searching for the string "rgba(".</summary>
        internal static readonly SearchValues<string> s_indexOfString_51CECF572885F990C73E7697216BC69E1AA29EEBA5DD34AEDC627AE466501040 = SearchValues.Create(["rgba("], StringComparison.Ordinal);
        
        /// <summary>Supports searching for the string "(You guessed".</summary>
        internal static readonly SearchValues<string> s_indexOfString_8BBF393C3188D3D271FBEB4959A25275CA6CDB7C9743E36C4BCCCD1CB765BDF3 = SearchValues.Create(["(You guessed"], StringComparison.Ordinal);
        
        /// <summary>Supports searching for the string "mul(".</summary>
        internal static readonly SearchValues<string> s_indexOfString_96014D68D1DA3A16D426C930D9D5FE25B48BBEF3E7AA9B0FFBC6DD9BE4DC8030 = SearchValues.Create(["mul("], StringComparison.Ordinal);
        
        /// <summary>Supports searching for the string "[Continue to Part Two".</summary>
        internal static readonly SearchValues<string> s_indexOfString_E6A228B76E9376A6FE0666728213354BCEC4D51363BA02D548FA5A6F5FE48479 = SearchValues.Create(["[Continue to Part Two"], StringComparison.Ordinal);
        
        /// <summary>Supports searching for characters in or not in "\t\n\v\f\r \u0085             \u2028\u2029  　".</summary>
        internal static readonly SearchValues<char> s_whitespace = SearchValues.Create("\t\n\v\f\r \u0085             \u2028\u2029  　");
    }
}
